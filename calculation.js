// --- FILE: calculation.js (CONTRACTOR VERSION - MODIFIED) ---

/**
 * Builds a map of door style to pricing group for quick lookup.
 * (Copied from DIY app calculation.js for consistency with pricingData.json)
 * @param {Array} doorPricingGroups - Array of pricing group objects.
 * @returns {Object} - Map where keys are style names and values are price objects.
 */
function buildStylePriceMap(doorPricingGroups) {
  const styleMap = {};
  if (!Array.isArray(doorPricingGroups)) {
    console.error("[Calc Contractor] Invalid doorPricingGroups input:", doorPricingGroups);
    return styleMap;
  }
  for (const group of doorPricingGroups) {
    if (!group || !Array.isArray(group.styles)) continue;
    for (const style of group.styles) {
      if (typeof style === 'string') {
        styleMap[style] = {
          Painted: Number(group.Painted) || 0,
          Primed: Number(group.Primed) || 0,
          Unfinished: Number(group.Unfinished) || 0
        };
      }
    }
  }
  return styleMap;
}

/** Calculate Area (sq ft) from inches. */
function calculateArea(height, width) {
  const numHeight = parseFloat(height);
  const numWidth = parseFloat(width);
  if (isNaN(numHeight) || isNaN(numWidth) || numHeight <= 0 || numWidth <= 0) {
    return 0;
  }
  return (numHeight * numWidth) / 144;
}

/**
 * Get price per sq ft for door/drawer style/finish using the style map.
 * @param {Object} styleMap - The map generated by buildStylePriceMap.
 * @param {string} style - The door/drawer style name.
 * @param {string} finish - The finish type.
 * @returns {number} - Price per square foot, or 0 if not found.
 */
function getPriceFromMap(styleMap, style, finish) {
  return styleMap?.[style]?.[finish] ?? 0;
}


/** Calculate cost for one Rough Estimate section. */
function calculateSectionCost(section, styleMap) { // Changed second arg to styleMap
  const area = calculateArea(section.height, section.width);
  const doorPrice = getPriceFromMap(styleMap, section.doorStyle, section.finish); // Use map
  const drawerPrice = getPriceFromMap(styleMap, section.drawerStyle, section.finish); // Use map
  const doorCost = Number(area * doorPrice) || 0;
  const drawerCost = (section.doorStyle === section.drawerStyle || drawerPrice === 0) ? 0 : (Number(area * drawerPrice) || 0);

  return {
      area: Number(area.toFixed(4)),
      doorCost: Number(doorCost.toFixed(2)),
      drawerCost: Number(drawerCost.toFixed(2)),
      totalSectionCost: Number((doorCost + drawerCost).toFixed(2)),
      // Echo back inputs
      doorStyle: section.doorStyle,
      drawerStyle: section.drawerStyle,
      finish: section.finish,
      height: section.height,
      width: section.width
    };
}

/** Calculate hinge drilling cost. */
function calculateHingeCost(part2, hingeCosts) {
    if (!part2 || !hingeCosts) return 0;
    const d0_36 = Number(part2.doors_0_36 || 0);
    const d36_60 = Number(part2.doors_36_60 || 0);
    const d60_82 = Number(part2.doors_60_82 || 0);
    const c0_36 = Number(hingeCosts?.["0-36"] || 0); // Use optional chaining
    const c36_60 = Number(hingeCosts?.["36.01-60"] || 0);
    const c60_82 = Number(hingeCosts?.["60.01-82"] || 0);
    return (d0_36 * c0_36) + (d36_60 * c36_60) + (d60_82 * c60_82);
}

/** Calculate special features cost (custom paint). */
function calculateSpecialFeaturesCost(part3, pricingData) {
    if (!part3 || !pricingData || !pricingData.customPaint) return { customPaintCost: 0 };
    const qty = Number(part3.customPaintQty || 0);
    const price = Number(pricingData.customPaint.price || 0);
    return { customPaintCost: qty * price };
}

/** Calculate refinishing cost. */
function calculateRefinishingCost(totalSqFt, refinishingCostPerSqFt) {
  const sqFt = Number(totalSqFt) || 0;
  const costPerSqFt = Number(refinishingCostPerSqFt) || 0;
  return sqFt * costPerSqFt;
}

/** Calculate installation cost. */
function calculateInstallationCost(priceSetup, part2) {
    if (!priceSetup || !part2) return { doorInstall: 0, drawerInstall: 0, lazySusanInstall: 0, totalInstall: 0 };
    const totalDoors = Number(part2.totalDoors || 0); // Actual doors from input
    const totalDrawers = parseInt(part2.numDrawers) || 0;
    const lazySusanQty = parseInt(part2.lazySusanQty) || 0;
    const pricePerDoor = Number(priceSetup.pricePerDoor) || 0;
    const pricePerDrawer = Number(priceSetup.pricePerDrawer) || 0;
    const pricePerLazySusan = Number(priceSetup.pricePerLazySusan) || 0;
    const doorInstall = totalDoors * pricePerDoor;
    const drawerInstall = totalDrawers * pricePerDrawer;
    const lazySusanInstall = lazySusanQty * pricePerLazySusan;
    return {
      doorInstall,
      drawerInstall,
      lazySusanInstall,
      totalInstall: doorInstall + drawerInstall + lazySusanInstall
    };
}

/**
 * Main calculation function for Contractor App.
 * @param {Object} payload - Client payload (includes priceSetup).
 * @param {Object} pricingData - Pricing JSON (expects doorPricingGroups).
 * @returns {Object} Breakdown of results including contractor metrics.
 */
function calculateOverallTotal(payload, pricingData) {
  // Basic validation
  if (!payload || !payload.sections || !payload.part2 || !payload.part3 || !payload.priceSetup) {
      throw new Error("Invalid payload structure received. Missing sections, part2, part3, or priceSetup.");
  }
  if (!pricingData || !pricingData.doorPricingGroups || !pricingData.hingeCosts || !pricingData.customPaint || !pricingData.lazySusan) { // Check for lazySusan price
       throw new Error("Invalid pricingData structure. Missing doorPricingGroups, hingeCosts, customPaint, or lazySusan.");
  }

  // --- Build Style Map from pricingData.doorPricingGroups ---
  const styleMap = buildStylePriceMap(pricingData.doorPricingGroups);

  // Calculate section costs
  let totalAllSectionCost = 0;
  const sectionBreakdown = [];
   // Ensure sections is an array before iterating
   const sections = Array.isArray(payload.sections) ? payload.sections : [];
   sections.forEach(section => {
    if(section && typeof section === 'object'){
        const result = calculateSectionCost(section, styleMap); // Pass styleMap
        sectionBreakdown.push(result);
        totalAllSectionCost += result.totalSectionCost || 0;
    } else { console.warn("[Calc Contractor] Skipping invalid section in payload:", section); }
  });


  // Hinge cost
  const hingeCost = calculateHingeCost(payload.part2, pricingData.hingeCosts);

  // Special features cost
  const specialFeatures = calculateSpecialFeaturesCost(payload.part3, pricingData);

  // Total Square Footage (Use the value sent from client, previously calculated there)
  const totalSqFt = Number(payload.priceSetup?.onSiteMeasuringSqFt || 0);
  if (totalSqFt === 0 && sections.length > 0) {
      console.warn("[Calc Contractor] priceSetup.onSiteMeasuringSqFt is 0 or missing, but sections exist. Refinishing cost might be incorrect.");
  }

  // Refinishing cost
  const refinishingCost = calculateRefinishingCost(totalSqFt, payload.priceSetup?.refinishingCostPerSqFt);

  // Measuring cost
  const measuringCost = Number(payload.priceSetup?.onSiteMeasuring || 0);

  // Installation cost (based on actual inputs)
  const installation = calculateInstallationCost(payload.priceSetup, payload.part2);

  // Conditional Disposal Cost Calculation
  let disposalCost = 0;
  let doorsForDisposal = 0;
  let drawersForDisposal = 0;
  let lazySusansForDisposal = 0;

  // Check the flag from part3
  if (payload.part3?.calculateDisposal === 'yes') {
    doorsForDisposal = Number(payload.part2?.totalDoors || 0); // Actual doors
    drawersForDisposal = Number(payload.part2?.numDrawers || 0); // Number of drawers
    lazySusansForDisposal = Number(payload.part2?.lazySusanQty || 0);

    const doorDisposalRate = Number(payload.priceSetup?.doorDisposalCost || 0);
    if (doorDisposalRate === 0) {
        console.warn("[Calc Contractor] Disposal requested, but doorDisposalCost is 0 or missing in priceSetup.");
    }

    // Calculate total units: Doors + Drawers + (Lazy Susans * 2)
    const totalDisposalUnits = doorsForDisposal + drawersForDisposal + (lazySusansForDisposal * 2);
    disposalCost = totalDisposalUnits * doorDisposalRate;
  }

  // Calculate Lazy Susan Surcharge (Use price from pricingData)
  const lazySusanQty = Number(payload.part2?.lazySusanQty || 0);
  const lazySusanSurchargePerUnit = Number(pricingData.lazySusan?.price || 0); // Get price from data file
   if (lazySusanSurchargePerUnit === 0 && lazySusanQty > 0) {
       console.warn("[Calc Contractor] Lazy Susan quantity provided, but lazySusan.price is 0 or missing in pricingData.json.");
   }
  const lazySusanSurchargeTotal = lazySusanQty * lazySusanSurchargePerUnit;


  // Cost to Installer (Sum of section costs + hinge cost)
  const costToInstaller = totalAllSectionCost + hingeCost;

  // Overall Total (Sum of all calculated costs)
  const overallTotal =
    totalAllSectionCost +
    hingeCost +
    (specialFeatures.customPaintCost || 0) +
    refinishingCost +
    measuringCost +
    (installation.totalInstall || 0) +
    disposalCost +
    lazySusanSurchargeTotal; // Added surcharge correctly


  // Profit Margin (Overall Total - Cost to Installer)
  const profitMargin = overallTotal - costToInstaller;

  // Hinge Count Calculation
  const hingeCount =
    (Number(payload.part2?.doors_0_36 || 0) * 2) +
    (Number(payload.part2?.doors_36_60 || 0) * 3) +
    (Number(payload.part2?.doors_60_82 || 0) * 4);

  // Format final results safely
  const format = (num) => Number((Number(num) || 0).toFixed(2));

  return {
    overallTotal: format(overallTotal),
    doorCostTotal: format(totalAllSectionCost), // Base cost from sections
    costToInstaller: format(costToInstaller),    // Section Cost + Hinge Cost
    profitMargin: format(profitMargin),        // Overall - CostToInstaller
    hingeCost: format(hingeCost),
    hingeCount,
    specialFeatures: { customPaintCost: format(specialFeatures.customPaintCost || 0) },
    refinishingCost: format(refinishingCost),
    measuringCost: format(measuringCost),
    installation: { // Installation costs based on actual counts
        doorInstall: format(installation.doorInstall || 0),
        drawerInstall: format(installation.drawerInstall || 0),
        lazySusanInstall: format(installation.lazySusanInstall || 0),
        totalInstall: format(installation.totalInstall || 0)
    },
    lazySusanSurcharge: format(lazySusanSurchargeTotal), // Return surcharge explicitly if needed
    disposalCost: format(disposalCost),
    // Include counts used for disposal calculation
    doorsForDisposal,
    drawersForDisposal,
    lazySusansForDisposal,
    // Pass back original inputs for display/consistency
    sections: sectionBreakdown,
    part2: payload.part2, // Contains original counts needed by frontend
    part3: payload.part3, // Contains disposal flag
    priceSetup: payload.priceSetup // Contains rates used
  };
}

module.exports = {
  calculateOverallTotal
};